import logging
from typing import Any, Optional

from django.conf import settings
from django.contrib import messages
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.forms import Media
from django.http import HttpRequest
from django.utils.safestring import mark_safe

from .models import TranslationTask
from .services import TranslationService
from .tasks import translate_instance_task

logger = logging.getLogger(__name__)


class DynamicParlerStyleMixin:
    """
    Mixin that injects the dynamic CSS file into the admin media.
    The CSS file is generated by a view (`admin_dynamic_parler_css_view`)
    that reads the current settings.PARLER_LANGUAGES to apply custom styling
    to language tabs.
    """

    @property
    def media(self):
        """
        Injects the dynamic CSS link after the base admin media.
        """
        media = super().media  # type: ignore[misc]
        return media + Media(css={"all": ("/admin/dynamic-parler-fixes.css",)})


class AutomatedTranslationModelMixin:
    """
    Mixin for models that automatically triggers GPT translations.
    Requires 'translation_service_method' to be defined.
    """

    translation_service_method: Optional[str] = None
    translation_trigger_fields: list[str] = ["name"]

    def trigger_translations(self, **kwargs: Any) -> list[str]:
        """
        Loops through supported languages and triggers translations if needed.
        Returns a list of language codes that are now in PENDING/RUNNING state.
        """
        if not self.translation_service_method:
            return []

        default_lang = settings.DEFAULT_APP_LANGUAGE
        supported_languages = TranslationService.get_available_languages()
        content_type = ContentType.objects.get_for_model(self)  # type: ignore[arg-type]
        active_languages = []

        for lang_code in supported_languages:
            if lang_code == default_lang:
                continue

            # Check if already triggered
            is_active = TranslationTask.objects.filter(
                content_type=content_type,
                object_id=str(self.pk),
                language=lang_code,
                status__in=[TranslationTask.Status.PENDING, TranslationTask.Status.RUNNING],
            ).exists()

            if is_active:
                active_languages.append(lang_code)
                continue

            # Need to trigger?
            if self._needs_translation(self, lang_code, default_lang):
                self._trigger_translation(
                    self, lang_code, content_type, self.translation_service_method, **kwargs
                )
                active_languages.append(lang_code)

        return active_languages

    def _needs_translation(self, obj: Any, lang_code: str, default_lang: str) -> bool:
        """
        Determines if the target language needs a translation.
        Triggers if ANY of the trigger fields are effectively empty in the target
        language, provided the source language (English) has content for that field.
        """
        if not hasattr(obj, "get_translation"):
            return False

        # 0. Skip if a task is already PENDING or RUNNING for this object/language
        content_type = ContentType.objects.get_for_model(obj)
        if TranslationTask.objects.filter(
            content_type=content_type,
            object_id=str(obj.pk),
            language=lang_code,
            status__in=[TranslationTask.Status.PENDING, TranslationTask.Status.RUNNING],
        ).exists():
            logger.debug(
                f"[_needs_translation] {obj} {lang_code}: Task already in progress. Skipping."
            )
            return False

        for field in self.translation_trigger_fields:
            # 1. Get Target Value (strictly for lang_code, no fallback)
            try:
                target_trans = obj.get_translation(lang_code)
                target_val = getattr(target_trans, field, None)
            except obj.translations.model.DoesNotExist:
                target_val = None

            if TranslationService.is_empty_text(target_val):
                # 2. Target is empty. Check if Source has something to translate FROM.
                try:
                    source_trans = obj.get_translation(default_lang)
                    source_val = getattr(source_trans, field, None)
                except obj.translations.model.DoesNotExist:
                    source_val = None

                if not TranslationService.is_empty_text(source_val):
                    logger.debug(
                        f"[_needs_translation] {obj} {lang_code}: "
                        f"Field '{field}' is empty (source has content). Triggering."
                    )
                    return True

        logger.debug(f"[_needs_translation] {obj} {lang_code}: No fields need translation.")
        return False

    def _trigger_translation(
        self,
        obj: Any,
        lang_code: str,
        content_type: ContentType,
        method_name: str,
        **kwargs: Any,
    ) -> str:
        """Dispatches an async translation task and tracks it."""
        object_id = str(obj.pk)

        # Clean up old completed/failed tasks
        TranslationTask.objects.filter(
            content_type=content_type,
            object_id=object_id,
            language=lang_code,
            status__in=[TranslationTask.Status.COMPLETED, TranslationTask.Status.FAILED],
        ).delete()

        # Dispatch async task
        task = translate_instance_task.delay(
            model_name=obj._meta.label,
            instance_pk=obj.pk,
            language_code=lang_code,
            method_name=method_name,
            **kwargs,
        )

        # Create/Update TranslationTask record
        TranslationTask.objects.update_or_create(
            content_type=content_type,
            object_id=object_id,
            language=lang_code,
            defaults={
                "method": method_name,
                "task_id": task.id,
                "status": TranslationTask.Status.PENDING,
            },
        )
        return task.id


class AutomatedTranslationAdminMixin:
    """
    Mixin for ModelAdmin classes that automatically triggers GPT translations.
    This is now a wrapper around AutomatedTranslationModelMixin logic
    to provide Admin-specific messaging.
    """

    def save_model(self, request: HttpRequest, obj: models.Model, form: Any, change: bool) -> None:
        """
        Overrides save_model to trigger translations and show messages.
        """
        # Ensure model is saved first
        super().save_model(request, obj, form, change)  # type: ignore[misc]

        # Trigger via model logic if available, otherwise do nothing (or fallback)
        if hasattr(obj, "trigger_translations"):
            kwargs = self.get_translation_kwargs(obj, form, change, True)
            triggered_languages = obj.trigger_translations(**kwargs)

            if triggered_languages:
                lang_list = ", ".join(triggered_languages)
                self.message_user(
                    request,
                    f"Translations queued for {len(triggered_languages)} "
                    f"languages ({lang_list})",
                    level=messages.SUCCESS,
                )

    def get_translation_kwargs(
        self, obj: Any, form: Any, change: bool, should_trigger: bool
    ) -> dict[str, Any]:
        """
        Hook to provide extra arguments to the translation service method.
        """
        return {}


class TranslationStatusMixin:
    """
    Mixin to add translation status column to admin list views.
    Use alongside AutomatedTranslationMixin.
    """

    def get_list_display(self, request: HttpRequest) -> list[str]:
        """Add translation_status to list_display if not already present."""
        list_display = super().get_list_display(request)  # type: ignore[misc]
        if "translation_status" not in list_display:
            return list(list_display) + ["translation_status"]
        return list(list_display)

    def translation_status(self, obj: models.Model) -> str:
        """Show aggregated status for all language tasks."""
        tasks = TranslationTask.objects.filter(
            content_type=ContentType.objects.get_for_model(obj), object_id=str(obj.pk)
        )

        if not tasks.exists():
            return mark_safe('<span style="color:gray">➖ Not Started</span>')

        statuses = list(tasks.values_list("status", flat=True))
        failed_count = statuses.count(TranslationTask.Status.FAILED)
        pending_running = sum(
            1
            for s in statuses
            if s in [TranslationTask.Status.PENDING, TranslationTask.Status.RUNNING]
        )

        if failed_count > 0:
            return mark_safe(
                f'<span style="color:red" title="{failed_count} failed">'
                f"❌ Failed ({failed_count})</span>"
            )
        elif pending_running > 0:
            return mark_safe(
                f'<span style="color:orange" title="{pending_running} in progress">'
                f"⏳ In Progress ({pending_running})</span>"
            )
        elif all(s == TranslationTask.Status.COMPLETED for s in statuses):
            return mark_safe(
                f'<span style="color:green" title="{len(statuses)} completed">'
                f"✅ Complete</span>"
            )

        return mark_safe('<span style="color:gray">➖ Unknown</span>')

    translation_status.short_description = "Translation Status"


class HideNonTranslatableFieldsMixin:
    """
    Mixin to dynamically hide non-translatable fields when editing a translation.
    If the current language is NOT the default language, show only translatable fields.
    """

    def get_fieldsets(self, request: HttpRequest, obj=None):
        base_fieldsets = super().get_fieldsets(request, obj)  # type: ignore[misc]

        # If no object (add view), return default fieldsets
        if not obj:
            return base_fieldsets

        # Get the current language being edited (from query param or Parler default)
        # Use get_form_language if available (TranslatableAdmin), otherwise fallback
        if hasattr(self, "get_form_language"):
            current_language = self.get_form_language(request, obj)
        else:
            current_language = request.GET.get("language")

        default_language = settings.DEFAULT_APP_LANGUAGE

        # If editing original content (default language) or no language set, show everything
        if not current_language or current_language == default_language:
            return base_fieldsets

        # If editing a translation, filter fieldsets to only show translatable fields
        # usage: translatable_fields = ["short_description", "bio"]
        if not hasattr(self, "translatable_fields"):
            return base_fieldsets

        filtered_fieldsets = []

        for name, opts in base_fieldsets:
            fields = opts.get("fields", ())
            # Filter fields in this fieldset
            visible_fields = [f for f in fields if f in self.translatable_fields]

            if visible_fields:
                # Create a copy of options with filtered fields
                new_opts = opts.copy()
                new_opts["fields"] = tuple(visible_fields)
                filtered_fieldsets.append((name, new_opts))

        return tuple(filtered_fieldsets)
