from typing import Any, Optional

from django.conf import settings
from django.contrib import messages
from django.contrib.contenttypes.models import ContentType
from django.forms import Media
from django.utils.safestring import mark_safe

from .models import TranslationTask
from .services import TranslationService
from .tasks import translate_instance_task


class DynamicParlerStyleMixin:
    """
    Mixin that injects the dynamic CSS file into the admin media.
    The CSS file is generated by a view (`admin_dynamic_parler_css_view`)
    that reads the current settings.PARLER_LANGUAGES to apply custom styling
    to language tabs.
    """

    @property
    def media(self):
        """
        Injects the dynamic CSS link after the base admin media.
        """
        media = super().media
        return media + Media(css={"all": ("/admin/dynamic-parler-fixes.css",)})


class AutomatedTranslationMixin:
    """
    Mixin for ModelAdmin classes that automatically triggers GPT translations.
    Requires 'translation_service_method' to be defined (e.g., 'translate_astro_image').
    """

    translation_service_method: Optional[str] = None
    translation_trigger_fields: list[str] = ["name"]

    def save_model(self, request: Any, obj: Any, form: Any, change: bool) -> None:  # noqa: C901
        """
        Overrides save_model to trigger translations if:
        1. Translations don't exist for a language
        2. Existing translations differ from the main language value
        """
        super().save_model(request, obj, form, change)

        if not self.translation_service_method:
            return

        # Get the main language value for comparison
        default_lang = getattr(settings, "PARLER_DEFAULT_LANGUAGE_CODE", "en")
        supported_languages = TranslationService.get_available_languages()

        # Pre-fetch ContentType to avoid repeated queries
        content_type = ContentType.objects.get_for_model(obj)
        object_id = str(obj.pk)

        triggered_languages = []

        for lang_code in supported_languages:
            if lang_code == default_lang:
                continue

            should_translate = False

            # Check if translation exists for this language
            if hasattr(obj, "translations"):
                # Get the BASE language translation to compare against
                try:
                    base_translation = obj.translations.get(language_code=default_lang)
                except obj.translations.model.DoesNotExist:
                    # BASE translation doesn't exist - skip this language
                    continue

                try:
                    translation = obj.translations.get(language_code=lang_code)
                    # Check if translation differs from BASE language
                    # Compare the trigger fields between BASE and target language
                    for field in self.translation_trigger_fields:
                        base_value = getattr(base_translation, field, None)
                        translated_value = getattr(translation, field, None)
                        if base_value != translated_value:
                            should_translate = True
                            break
                except obj.translations.model.DoesNotExist:
                    # Translation doesn't exist - should translate
                    should_translate = True
            else:
                # Not a translatable model, skip
                continue

            if should_translate:
                # Clean up old completed/failed tasks for this language to avoid conflicts
                TranslationTask.objects.filter(
                    content_type=content_type,
                    object_id=object_id,
                    language=lang_code,
                    status__in=[TranslationTask.Status.COMPLETED, TranslationTask.Status.FAILED],
                ).delete()

                # robustly determine method name if not explicitly set (fallback mechanism)
                method_name = self.translation_service_method
                kwargs = self.get_translation_kwargs(obj, form, change, should_translate)

                # Dispatch async task
                kwargs["force"] = True
                task = translate_instance_task.delay(
                    model_name=obj._meta.label,
                    instance_pk=obj.pk,
                    language_code=lang_code,
                    method_name=method_name,
                    **kwargs,
                )

                # Create/Update TranslationTask record tracking the Celery task ID
                TranslationTask.objects.update_or_create(
                    content_type=content_type,
                    object_id=object_id,
                    language=lang_code,
                    defaults={
                        "method": method_name,
                        "task_id": task.id,
                        "status": TranslationTask.Status.PENDING,
                    },
                )
                triggered_languages.append(lang_code)

        if triggered_languages:
            lang_list = ", ".join(triggered_languages)
            self.message_user(
                request,
                f"Translations queued for {len(triggered_languages)} " f"languages ({lang_list})",
                level=messages.SUCCESS,
            )

    def get_translation_kwargs(
        self, obj: Any, form: Any, change: bool, should_trigger: bool
    ) -> dict[str, Any]:
        """
        Hook to provide extra arguments to the translation service method.
        """
        return {}


class TranslationStatusMixin:
    """
    Mixin to add translation status column to admin list views.
    Use alongside AutomatedTranslationMixin.
    """

    def get_list_display(self, request: Any) -> list[str]:
        """Add translation_status to list_display if not already present."""
        list_display = super().get_list_display(request)
        if "translation_status" not in list_display:
            return list(list_display) + ["translation_status"]
        return list(list_display)

    def translation_status(self, obj: Any) -> str:
        """Show aggregated status for all language tasks."""
        tasks = TranslationTask.objects.filter(
            content_type=ContentType.objects.get_for_model(obj), object_id=str(obj.pk)
        )

        if not tasks.exists():
            return mark_safe('<span style="color:gray">➖ Not Started</span>')

        statuses = list(tasks.values_list("status", flat=True))
        failed_count = statuses.count(TranslationTask.Status.FAILED)
        pending_running = sum(
            1
            for s in statuses
            if s in [TranslationTask.Status.PENDING, TranslationTask.Status.RUNNING]
        )

        if failed_count > 0:
            return mark_safe(
                f'<span style="color:red" title="{failed_count} failed">'
                f"❌ Failed ({failed_count})</span>"
            )
        elif pending_running > 0:
            return mark_safe(
                f'<span style="color:orange" title="{pending_running} in progress">'
                f"⏳ In Progress ({pending_running})</span>"
            )
        elif all(s == TranslationTask.Status.COMPLETED for s in statuses):
            return mark_safe(
                f'<span style="color:green" title="{len(statuses)} completed">'
                f"✅ Complete</span>"
            )

        return mark_safe('<span style="color:gray">➖ Unknown</span>')

    translation_status.short_description = "Translation Status"
