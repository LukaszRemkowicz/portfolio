name: CI/CD Pipeline

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]
  workflow_dispatch:

env:
  PYTHON_VERSION: "3.13"
  NODE_VERSION: "20"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  # Versioning
  version-check:
    name: Version bump check (dev ‚Üí main)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR HEAD
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate VERSION file and bump
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          BASE_REF: ${{ github.base_ref }}
          HEAD_REF: ${{ github.head_ref }}
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail

          if [[ "$EVENT_NAME" != "pull_request" ]] || \
            [[ "$BASE_REF" != "main" ]] || \
            [[ "$HEAD_REF" != "dev" ]]; then
            echo "‚ÑπÔ∏è Version check skipped (not dev ‚Üí main PR)."
            exit 0
          fi

          VERSION_FILE="VERSION"

          echo "üîé Version check (dev ‚Üí main)"
          echo "üìå Base SHA: $BASE_SHA"
          echo "üìå Head SHA: $HEAD_SHA"

          # PR/DEV must have VERSION
          if ! git cat-file -e "${HEAD_SHA}:${VERSION_FILE}" 2>/dev/null; then
            echo "‚ùå ERROR: ${VERSION_FILE} is missing in PR branch (dev)."
            exit 1
          fi

          NEW="$(git show "${HEAD_SHA}:${VERSION_FILE}" | tr -d ' \t\r\n')"
          if ! [[ "$NEW" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå ERROR: VERSION must be MAJOR.MINOR.PATCH (e.g. 1.0.2). Got: '$NEW'"
            exit 1
          fi

          # If main/base doesn't have VERSION yet -> bootstrap pass
          if ! git cat-file -e "${BASE_SHA}:${VERSION_FILE}" 2>/dev/null; then
            echo "‚ö†Ô∏è  Bootstrap: ${VERSION_FILE} does not exist on base branch (main)."
            echo "‚úÖ PR introduces VERSION: $NEW"
            echo "üè∑Ô∏è  Release tag would be: v$NEW"
            exit 0
          fi

          OLD="$(git show "${BASE_SHA}:${VERSION_FILE}" | tr -d ' \t\r\n')"
          if ! [[ "$OLD" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå ERROR: Base VERSION is invalid on main. Got: '$OLD'"
            exit 1
          fi

          echo "üî¢ Base version: $OLD"
          echo "üî¢ PR version:   $NEW"

          if [[ "$OLD" == "$NEW" ]]; then
            echo "‚ùå ERROR: VERSION was not changed in this PR (still $NEW)."
            exit 1
          fi

          IFS='.' read -r oldM oldm oldp <<< "$OLD"
          IFS='.' read -r newM newm newp <<< "$NEW"

          # Require strictly greater
          if (( newM < oldM )) || \
            (( newM == oldM && newm < oldm )) || \
            (( newM == oldM && newm == oldm && newp <= oldp )); then
            echo "‚ùå ERROR: VERSION must increase. Base=$OLD PR=$NEW"
            exit 1
          fi

          echo "‚úÖ VERSION bump is valid: $OLD ‚Üí $NEW"
          echo "üè∑Ô∏è  Release tag would be: v$NEW"

  # Frontend: Lint, Type Check, and Test
  frontend:
    needs: [version-check]
    name: Frontend Quality & Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run ESLint
        working-directory: ./frontend
        run: npm run lint

      - name: Run Prettier check
        working-directory: ./frontend
        run: npm run format:check || (npx prettier --list-different 'src/**/*.{ts,tsx,css}' && exit 1)

      - name: TypeScript type check
        working-directory: ./frontend
        run: npx tsc --noEmit

      - name: Run tests
        working-directory: ./frontend
        run: npm test -- --coverage --watchAll=false
        env:
          API_URL: http://localhost:8000

      - name: Upload coverage reports
        if: github.event_name == 'push'
        uses: codecov/codecov-action@v4
        with:
          files: ./frontend/coverage/lcov.info
          flags: frontend
          token: ${{ secrets.CODECOV_TOKEN }}

  # Backend: Lint, Type Check, and Test
  backend:
    needs: [version-check]
    name: Backend Quality & Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    env:
      DB_HOST: localhost
      DB_NAME: test_db
      DB_USER: postgres
      DB_PASSWORD: postgres
      DB_PORT: 5432
      DEFAULT_FROM_EMAIL: test@example.com
      CONTACT_EMAIL: test@example.com
      SESSION_COOKIE_DOMAIN: .example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: latest
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Cache Poetry virtualenv
        uses: actions/cache@v4
        with:
          path: backend/.venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('backend/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-

      - name: Install dependencies
        working-directory: ./backend
        run: poetry install --no-root --no-interaction

      - name: Run Python linting
        working-directory: ./backend
        run: |
          poetry run flake8 .
          poetry run black --check .

      - name: Run Python type checking
        working-directory: ./backend
        run: poetry run mypy .

      - name: Run tests
        working-directory: ./backend
        run: |
          poetry run pytest --cov=. --cov-report=xml

      - name: Upload coverage reports
        if: github.event_name == 'push'
        uses: codecov/codecov-action@v4
        with:
          files: ./backend/coverage.xml
          flags: backend
          token: ${{ secrets.CODECOV_TOKEN }}

  # Docker Build/Test
  docker-build:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [frontend, backend]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Cache Docker Images
        uses: docker/bake-action@v6.0.0
        with:
          push: false
          load: true
          set: |
            *.cache-from=type=gha
            *.cache-to=type=gha,mode=max

  # Security Scanning
  security-scan:
    name: Security Analysis
    runs-on: ubuntu-latest
    needs: [frontend, backend]
    permissions:
      security-events: write
      actions: read
      contents: read
    env:
      DB_HOST: localhost
      DB_NAME: test_db
      DB_USER: postgres
      DB_PASSWORD: postgres
      DB_PORT: 5432
      DEFAULT_FROM_EMAIL: test@example.com
      CONTACT_EMAIL: test@example.com
      SESSION_COOKIE_DOMAIN: .example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run npm audit
        working-directory: ./frontend
        run: npm audit --audit-level=moderate

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache Poetry virtualenv
        uses: actions/cache@v4
        with:
          path: backend/.venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('backend/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-

      - name: Install dependencies
        working-directory: ./backend
        run: poetry install --no-root --no-interaction

      - name: Backend safety check
        working-directory: ./backend
        run: |
          poetry run pip install safety
          poetry run safety check

  # PR Status Reporting
  pr-status:
    name: PR Status Report
    runs-on: ubuntu-latest
    needs: [frontend, backend, docker-build, security-scan]
    if: always() && github.event_name == 'pull_request'
    permissions:
      pull-requests: write

    steps:
      - name: Report Status
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              'Frontend (Lint/Types/Tests)': '${{ needs.frontend.result }}',
              'Backend (Lint/Types/Tests)': '${{ needs.backend.result }}',
              'Docker Build': '${{ needs.docker-build.result }}',
              'Security Analysis': '${{ needs.security-scan.result }}'
            };

            const emoji = (s) => s === 'success' ? '‚úÖ' : (s === 'failure' ? '‚ùå' : '‚èπÔ∏è');

            let body = `## üöÄ CI/CD Pipeline Results\n\n| Check | Status |\n|---|---|\n`;
            for (const [name, res] of Object.entries(results)) {
              body += `| ${name} | ${emoji(res)} ${res} |\n`;
            }

            const allSuccess = Object.values(results).every(s => s === 'success');
            body += `\n${allSuccess ? 'üéâ **All checks passed!**' : '‚ö†Ô∏è **Some checks failed. Please review the logs.**'}`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c => c.body.includes('CI/CD Pipeline Results'));

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }

  # Tagging
  tag-main:
    name: Tag main from VERSION
    permissions:
      contents: write
    runs-on: ubuntu-latest
    needs: [frontend, backend, docker-build, security-scan]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create and push tag (if missing)
        shell: bash
        run: |
          set -euo pipefail

          git fetch origin main --tags

          # Find the latest tag matching v*
          # Use xargs to trim potential whitespace, although sort should handle it
          LATEST_TAG=$(git tag -l "v*" --sort=-v:refname | head -n 1)

          if [[ -z "$LATEST_TAG" ]]; then
            echo "‚ö†Ô∏è No previous release tag found. Proceeding with initial version."
          else
            echo "üè∑Ô∏è Latest release tag: $LATEST_TAG"

            # Extract version from old tag's VERSION file
            # tr -d is used to ensure no hidden characters interfere
            OLD_VER=$(git show "$LATEST_TAG:VERSION" | tr -d ' \t\r\n')
            CUR_VER=$(tr -d ' \t\r\n' < VERSION)

            if [[ "$OLD_VER" == "$CUR_VER" ]]; then
              echo "‚ÑπÔ∏è VERSION ($CUR_VER) has not changed since $LATEST_TAG. Skipping."
              exit 0
            fi
            echo "üöÄ Version change detected: $OLD_VER -> $CUR_VER"
          fi

          if [[ ! -f VERSION ]]; then
            echo "‚ùå ERROR: VERSION file missing on main."
            exit 1
          fi

          VER="$(tr -d ' \t\r\n' < VERSION)"
          if ! [[ "$VER" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå ERROR: VERSION must be MAJOR.MINOR.PATCH, got: '$VER'"
            exit 1
          fi

          TAG="v$VER"
          echo "üè∑Ô∏è  Target tag: $TAG"

          git fetch --tags
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "‚ÑπÔ∏è Tag already exists: $TAG (skipping)"
            exit 0
          fi

          git config user.name "github-actions"
          git config user.email "github-actions@github.com"

          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"

          echo "‚úÖ Created and pushed tag: $TAG"
